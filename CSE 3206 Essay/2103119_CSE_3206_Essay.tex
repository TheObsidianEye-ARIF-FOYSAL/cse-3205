\documentclass[12pt,a4paper]{article}

% ------------------------------------------------
% Packages
% ------------------------------------------------
\usepackage[utf8]{inputenc}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{titlesec}
\usepackage{xcolor}
\usepackage{fancyhdr}
\usepackage{setspace}
\usepackage{tcolorbox}
\usepackage{hyperref}
\usepackage{enumitem}
\usepackage{booktabs}
\usepackage{ragged2e}
\usepackage{listings}
\usepackage{courier}

\geometry{margin=1in}
\onehalfspacing

\hypersetup{
  colorlinks=true,
  linkcolor=blue,
  urlcolor=blue
}

% ------------------------------------------------
% Colors
% ------------------------------------------------
\definecolor{ruetblue}{RGB}{25,55,109}
\definecolor{accent}{RGB}{102,0,204}
\definecolor{lecturerorange}{RGB}{255,102,0}
\definecolor{lightgray}{RGB}{245,245,245}
\definecolor{codebg}{RGB}{248,249,255}
\definecolor{coderule}{RGB}{102,126,234}

% ------------------------------------------------
% Section Formatting
% ------------------------------------------------
\titleformat{\section}
{\color{ruetblue}\normalfont\Large\bfseries}
{\thesection}{1em}{}

\titleformat{\subsection}
{\color{accent}\normalfont\large\bfseries}
{\thesubsection}{1em}{}

% ------------------------------------------------
% Code Listing Style
% ------------------------------------------------
\lstdefinestyle{mystyle}{
  backgroundcolor=\color{codebg},
  basicstyle=\footnotesize\ttfamily,
  frame=single,
  rulecolor=\color{coderule},
  breaklines=true,
  columns=fullflexible,
  numbers=left,
  numberstyle=\tiny\color{ruetblue},
  keywordstyle=\color{accent}\bfseries,
  commentstyle=\color{ruetblue},
  stringstyle=\color{lecturerorange},
  showstringspaces=false
}
\lstset{style=mystyle}

% ------------------------------------------------
% Header/Footer
% ------------------------------------------------
\pagestyle{fancy}
\fancyhf{}
\fancyhead[L]{CSE 3206 -- Software Engineering Sessional}
\fancyhead[R]{CO4 Reflection Essay}
\fancyfoot[C]{\thepage}

% ============================================================
% DOCUMENT START
% ============================================================

\begin{document}

% ============================================================
% SINGLE-PAGE COVER
% ============================================================

\begin{titlepage}
\centering

\vspace*{0.5cm}

{\LARGE \textbf{\textcolor{ruetblue}{RAJSHAHI UNIVERSITY OF ENGINEERING \& TECHNOLOGY}}}\\[0.3cm]
{\large Department of Computer Science \& Engineering}\\[0.6cm]

\textcolor{accent}{\rule{\linewidth}{1.5pt}}\\[0.6cm]

{\LARGE \textbf{\textcolor{accent}{CO4 Reflection Essay}}}\\[0.2cm]
{\large CSE 3206 -- Software Engineering Sessional}\\[0.6cm]

\textcolor{accent}{\rule{\linewidth}{1.5pt}}\\[0.8cm]

\begin{tcolorbox}[colback=lightgray,colframe=ruetblue,width=0.85\linewidth]
\small
\textbf{Project Title:} Animal Classifier AI (Web Application)\\
\textbf{Submitted by:} Arif Foysal Bin Haider\\
\textbf{Section:} B \quad
\textbf{Series:} 21\\
\textbf{Course Code:} CSE 3206\\
\textbf{Date of Submission:} 12 February, 2026
\end{tcolorbox}

\vspace{0.6cm}

\begin{flushleft}
\large \textbf{Submitted to}\\[0.2cm]
\Large \textbf{\textcolor{ruetblue}{Md. Sozib Hossain}}\\
\textcolor{lecturerorange}{Lecturer}\\
Department of Computer Science \& Engineering, RUET
\end{flushleft}

\vspace{0.6cm}

\begin{tcolorbox}[colback=white,colframe=accent,width=0.85\linewidth]
\centering
\small
\textbf{Source Code Repository (LaTeX):}\\
\href{https://github.com/TheObsidianEye-ARIF-FOYSAL/cse-3205/blob/main/CSE%203206%20Essay/2103119_CSE_3206_Essay.tex}
{\textbf{View LaTeX Source on GitHub}}
\end{tcolorbox}

\vfill
\textcolor{ruetblue}{\rule{\linewidth}{1pt}}\\
\small \textit{Heaven's Light is Our Guide}
\end{titlepage}

% ============================================================
% ESSAY
% ============================================================

\section*{A Reflective Essay on Animal Classifier AI: A Software Engineering Web System}
\addcontentsline{toc}{section}{Reflection Essay}

\subsection*{0.1 Technical Decision and Justification}

Although the prediction is powered by a deep learning model, the core software engineering objective of this project was building a reliable \textbf{end-to-end web application} around that model. The most significant architectural decision I made was to design the system as a \textbf{client--server web application} with (1) a Flask backend exposing REST endpoints and (2) a frontend that communicates asynchronously using the Fetch API with \texttt{FormData}. This separation was technically superior to a server-rendered ``form submit + page reload'' approach because model inference is computationally expensive and can be slow or unpredictable in production hosting environments (cold starts, timeouts, and overload). A responsive UI therefore requires explicit state management and graceful failure handling.

\textbf{Rejected Alternative: Traditional Form Submission (Full Page Reload).}
Initially, I considered a basic HTML form that uploads an image and reloads the page with the result. I rejected this approach for two specific software engineering reasons:
\begin{enumerate}[leftmargin=*]
  \item \textbf{Poor UX and limited feedback:} A full page reload makes it difficult to provide progressive feedback (loader/spinner), disable buttons to prevent duplicate requests, or show precise error messages for different failure modes.
  \item \textbf{Weak error recovery:} When the server returns non-JSON errors (e.g., gateway failures) or times out, a form-based flow often collapses into generic browser errors. This is unacceptable for a production-style submission.
\end{enumerate}

\textbf{Why the async REST approach was better.}
My frontend behaves like a small state machine: it tracks the selected file, shows a preview, enables the prediction button, displays a loading spinner during the request, and then shows either a result card or an error panel. This architecture made it possible to implement robust behavior that is expected in real web applications:
\begin{itemize}[leftmargin=*]
  \item \textbf{Progressive enhancement:} click-to-upload works by default; drag-and-drop is layered on top.
  \item \textbf{Explicit UI states:} show/hide classes (\texttt{.show}) ensure predictable transitions.
  \item \textbf{Human-friendly failure modes:} different messages for server overload (502), cold start/service unavailable (503), and timeouts (504).
\end{itemize}

A small but important engineering choice was to treat failures as first-class citizens. In \texttt{script.js} I check \texttt{response.ok} before parsing JSON, and I handle cases where error responses contain no JSON body. This prevents UI crashes and makes the website resilient.

\begin{lstlisting}[language=JavaScript, caption={Robust request handling with UI state control (core pattern)}]
loader.classList.add('show');
predictBtn.disabled = true;

const response = await fetch('/predict', { method: 'POST', body: formData });

if (!response.ok) {
  let errorMsg = `Server error (${response.status})`;
  // map common production failures into user-friendly messages
  if (response.status === 503) errorMsg = 'Service unavailable. Server is starting up.';
  if (response.status === 504) errorMsg = 'Request timeout. Prediction took too long.';
  showError(errorMsg);
  return;
}

const data = await response.json();
showResult(data.prediction, data.confidence);
\end{lstlisting}

\textbf{Supporting Design Decisions.}
To keep the website maintainable and user-friendly, I designed three supporting components:
\begin{enumerate}[leftmargin=*]
  \item \textbf{UI/UX design system in CSS:} gradients, card layout, hover interactions, and a responsive breakpoint for small screens.
  \item \textbf{Result visualization:} confidence percentage plus an animated confidence bar improves interpretability.
  \item \textbf{Developer observability:} a dedicated diagnostic page for testing endpoints and response timing.
\end{enumerate}

\subsection*{0.2 Self-Directed Learning Experience}

Converting a model into a reliable website required learning engineering topics that go beyond training accuracy. The challenges I faced were mainly system-integration challenges, not ML-only challenges.

\textbf{Challenge 1: Frontend state synchronization without frameworks.}
I intentionally used vanilla JavaScript rather than React/Vue to strengthen my fundamentals. The difficulty was ensuring that every user action (select file, remove file, predict, error, retry) leads to a consistent UI. I solved this by:
\begin{itemize}[leftmargin=*]
  \item centralizing file selection into \texttt{handleFileSelect(file)}
  \item centralizing reset logic into \texttt{clearSelection()}
  \item controlling visibility using CSS classes (e.g., \texttt{.show})
\end{itemize}
This taught me that even small frontends need disciplined state management.

\textbf{Challenge 2: Real deployment failure modes (not seen locally).}
In local development, requests are fast and stable. In hosted environments, I encountered failure classes such as cold start delays, overloaded instances, and non-JSON gateway responses. My solution was to implement layered handling:
\begin{itemize}[leftmargin=*]
  \item check HTTP status before parsing JSON
  \item generate user-friendly messages for 502/503/504
  \item provide retry guidance rather than leaving the user stuck
\end{itemize}
This improved both reliability and user trust.

\textbf{Challenge 3: Debugging end-to-end systems with proper tooling.}
A major upgrade in my engineering workflow was building \texttt{diagnostic.html}, a small internal tool that tests:
\begin{itemize}[leftmargin=*]
  \item \texttt{/health} endpoint for server availability
  \item \texttt{/model-status} endpoint for model readiness
  \item \texttt{/predict} endpoint with request timing and JSON output
  \item CORS behavior by checking response headers
\end{itemize}
This transformed debugging from guesswork into measurable verification, similar to professional practice.

\textbf{Challenge 4: UX polish and responsiveness.}
I learned that software quality is not only correctness. The CSS includes micro-interactions (fade-in, hover scaling, dragover highlight, shake animation for errors) and mobile responsiveness. These details improved perceived performance and usability without changing backend logic.

\textbf{Evaluation of Learning Resources.}
During this phase, I learned to prioritize primary sources:
\begin{itemize}[leftmargin=*]
  \item \textbf{MDN Web Docs:} Best for Fetch, FormData, FileReader, and drag-and-drop events.
  \item \textbf{Flask documentation:} Best for route design and template rendering with \texttt{url\_for}.
  \item \textbf{Community threads:} Useful for quick fixes but required careful validation.
\end{itemize}
This taught me an important professional habit: use documentation-first for core behavior, and use community sources mainly for edge-case debugging.

\subsection*{0.3 Reflection and Future Learning Plan}

This project shifted my mindset from ``feature-first'' to ``system-first.'' I realized that building a web system means designing:
\begin{itemize}[leftmargin=*]
  \item predictable UI state transitions,
  \item clean API boundaries,
  \item failure handling and recovery,
  \item testability and observability.
\end{itemize}

\textbf{Next Learning Goal: Automated Testing + CI/CD for Web Applications.}
My next professional growth target is to establish software quality automation:
\begin{enumerate}[leftmargin=*]
  \item \textbf{API testing:} write tests for \texttt{/predict} to validate status codes, JSON schema, and edge cases (missing file, invalid type).
  \item \textbf{Frontend E2E testing:} simulate upload and prediction flow using a browser automation tool.
  \item \textbf{CI/CD pipeline:} use GitHub Actions to run tests on every push and prevent regressions.
\end{enumerate}

\textbf{Action Plan.}
\begin{itemize}[leftmargin=*]
  \item Week 1: Create API unit tests and validate error paths.
  \item Week 2: Add integration tests for JSON response format and latency thresholds.
  \item Week 3: Add end-to-end tests for the complete UI workflow.
  \item Week 4: Automate in GitHub Actions and enforce ``fail-fast'' quality gates.
\end{itemize}

\subsection*{Conclusion}

The Animal Classifier AI project is more than a model demonstration; it is a complete software engineering web system. By designing an asynchronous frontend, implementing reliable API communication, handling real production failures, building diagnostic tooling, and polishing responsive UI, I practiced key software engineering principles: maintainability, robustness, usability, and verifiability. Most importantly, the project gave me a repeatable method for self-directed learning: identify a system need, consult primary documentation, implement incrementally, and validate through testing and diagnostics. This methodology prepares me for continuous growth in modern software engineering.

\vspace{0.5cm}
\textcolor{ruetblue}{\rule{\linewidth}{1pt}}

\end{document}
